---
layout: post
title: n8n 初学笔记
date: 2025-10-21 12:00:00
forType: Workflow
category: n8n
tag: [n8n, 工作流自动化, 初学, 教程, 集成]
---

* content
{:toc}

# n8n 初学笔记概览

面向首次接触 n8n 的开发人员，快速理解 n8n 的定位、核心概念与使用路径，并可用于项目落地与实践参考。

## 入门指南

### n8n 是什么
n8n 是一个可视化、低代码的工作流自动化与集成平台。通过拖拽节点进行编排，开发者可以在不编写大量胶水代码的情况下，实现跨系统的数据流转与自动化。其特点包括：
- 可视化与低代码：拖拽节点、连线即可构建流程
- 节点生态丰富：内置大量常用服务与协议节点（HTTP、数据库、邮件等）
- 开源与自托管：支持本地/服务器部署，易于二次定制
- 可扩展：支持自定义 Function/Code 节点，表达式灵活

### 适用场景
- 数据同步：CRM → 数据仓库、第三方 API → 内部系统
- API 编排：组合多个第三方接口形成统一服务
- 通知告警：异常日志触发短信/邮件/IM 通知
- 轻量 ETL：定时采集、清洗、落库（适合中小规模）
- 内部自动化：审批流辅助、报表生成与推送

小示例：
- HTTP Webhook 接收事件 → Function 清洗数据 → 发送到 Slack/企业微信

### 学习路径
1. 安装：使用 Docker 快速启动 n8n
2. 核心概念：理解工作流、节点、触发器、表达式与凭据
3. 上手实践：构建第一个工作流（HTTP Trigger → Function → 通知）

## 安装与环境

### Docker 安装与启动（仅 Docker 方式）

#### 前置要求
- 已安装 Docker（建议 20+）与 Docker Compose（V2）
- 服务器/本机开放端口 `5678`（默认 Web 端口）

#### 快速启动（单容器）
```bash
# 创建数据持久化目录（macOS/Linux 示例）
mkdir -p ~/.n8n

# 启动 n8n 容器（最小可用示例）
docker run -it --rm \
  -p 5678:5678 \
  -v ~/.n8n:/home/node/.n8n \
  -e N8N_HOST=localhost \
  -e N8N_PORT=5678 \
  --name n8n \
  n8nio/n8n:latest
```
访问地址：`http://localhost:5678`（首次进入创建管理员）。

#### 推荐：Docker Compose
```yaml
# docker-compose.yml
version: "3.8"
services:
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    ports:
      - "5678:5678"
    environment:
      - N8N_HOST=localhost
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      # 反向代理/公网时需要：
      # - WEBHOOK_URL=http://your-domain-or-ip:5678/
      - TZ=Asia/Shanghai
    volumes:
      - ./n8n_data:/home/node/.n8n
    restart: unless-stopped
```
启动：
```bash
docker compose up -d
```

#### 数据持久化与备份
- 工作流、凭据等保存在挂载目录（示例：`./n8n_data`）
- 定期备份该目录即可完成迁移与恢复

#### 反向代理提示
- 使用 Nginx/Caddy 等做反向代理时，务必正确设置 `WEBHOOK_URL`
- HTTPS/域名场景下：`WEBHOOK_URL=https://your-domain/`

#### 常见问题
- 端口冲突：检查本机是否已有服务占用 `5678`
- 访问异常：反向代理未正确转发或未设置 `WEBHOOK_URL`
- 权限问题：挂载目录需对 Docker 进程可读写

## 核心概念

### 工作流（Workflow）与节点（Node）
- 工作流：由多个节点组成的有向图，通过连线决定执行顺序
- 节点：执行具体任务的单元（如 HTTP Request、Function、Set 等）
- 数据流：节点之间传递 `items`（JSON 对象数组），每个节点对输入进行处理并产生输出

### 触发器（Trigger）与执行（Execute）
- 触发器节点：如 Webhook、Schedule（Cron）、IMAP 等，用于“启动”工作流
- 手动执行：编辑器中点击“执行工作流”进行调试
- 运行方式：触发 → 依次执行下游节点 → 根据分支/条件流转

### 数据结构与表达式
- 数据结构：每个节点的输出通常是 `items: [{ json: {...} }]`
- 表达式：在字段中输入表达式以引用数据，例如：
  - `{{$json.name}}` 引用当前节点输入中的 `name`
  - `{{$node["HTTP Request"].json.status}}` 引用指定节点输出
  - `{{$flow.static}}` 引用工作流级变量，`{{$env.VAR}}` 引用环境变量
- 示例（Set 节点）：
```json
{
  "name": "{{$json.name}}",
  "status": "{{$node[\"HTTP Request\"].json.status}}",
  "ts": "{{$now}}"
}
```

### 凭据（Credentials）与连接配置
- 凭据：用于安全存储第三方服务的认证信息（API Key、OAuth2、Basic Auth 等）
- 使用方式：在节点中选择已保存的凭据，即可复用连接配置
- 最佳实践：使用环境变量注入敏感信息、限制权限、定期轮换密钥

## 快速上手

### 目标
通过一个可运行的示例快速理解 n8n 的编排方式：`HTTP Trigger → Function → HTTP Request`。

### 步骤详解
1. 创建工作流：进入编辑器，点击“新建”工作流并命名（如 `hello-demo`）。
2. 添加触发器：
   - 添加 `HTTP Trigger` 节点，设置 `Path=/demo`，`HTTP Method=POST`。
   - 保存后触发地址为：`http://localhost:5678/webhook/demo`。
3. 添加 `Function` 节点（处理数据）：
   - 代码示例：
   ```javascript
   // Function 节点（JavaScript）
   // 输入 items: [{ json: {...} }]
   // 输出同结构 items
   return items.map(item => {
     const data = item.json;
     return {
       json: {
         message: `Hello, ${data.name || 'n8n'}!`,
         ts: Date.now()
       }
     };
   });
   ```
4. 添加 `HTTP Request` 节点（发送结果）：
   - Method: `POST`
   - URL: `https://httpbin.org/post`（示例回显服务）
   - Body（JSON）：
     - `greeting`: `{{$json.message}}`
     - `timestamp`: `{{$json.ts}}`
5. 连线与保存：`HTTP Trigger → Function → HTTP Request`；点击“保存”。
6. 测试：
```bash
curl -X POST \
  http://localhost:5678/webhook/demo \
  -H 'Content-Type: application/json' \
  -d '{"name":"Alice"}'
```
- 期望：`HTTP Request` 节点请求成功，`httpbin.org` 回显包含 `greeting` 与 `timestamp`。

### 调试与排错
- 没有触发？确认访问的是 `webhook` 路径且方法匹配。
- `HTTP Request` 报错？检查 URL、网络、代理设置；必要时开启 `Continue On Fail` 便于排错。
- 数据不对？在每个节点的执行面板查看 `Input`/`Output` 的 `items` 结构，逐步定位。

## 常用节点与触发器

### 触发器节点（启动工作流）
- Webhook：接收外部事件（HTTP/JSON），API 编排常用。
- Schedule（Cron）：定时任务（如每天 8:00 拉取报表）。
- Interval：固定时间间隔轮询（如每 5 分钟检查队列）。
- IMAP/Email：邮箱来信触发，适合审批/通知流。
- Webhook + Secret：结合 Header 校验做入站安全控制。

### 处理与控制节点（编排逻辑）
- HTTP Request：与外部服务交互；支持 Header、Auth、Query、JSON/Form 等。
- Function / Code：用 JS 进行任意数据处理；Function 适合轻逻辑，Code 适合复杂脚本。
- Set：声明式设置/重命名/移除字段，便于数据预处理。
- IF / Switch：条件分支与多路分发；结合表达式实现精准路由。
- Merge：合并分支（按索引、按字段）、等待多路完成后汇总。
- Wait：等待一段时间或外部事件；配合重试/节流策略使用。

### 数据操作节点（Items 管理）
- Item Lists：映射（Map）、过滤（Filter）、聚合（Aggregate）。
- Move/Remove：移动或删除字段，保持输出结构稳定。
- Binary <-> JSON：处理文件与二进制数据（图片、CSV、Excel）。

### 集成示例与最佳实践
- 常用连接器：Slack/Telegram、Google Sheets、MySQL/PostgreSQL、S3/OSS、Notion/Jira。
- 最佳实践：
  - 把鉴权放在“凭据”里统一管理；
  - 对外部 API 使用超时、重试与限速；
  - 关键路径加 `IF` 分支与错误兜底（例如写入告警队列）。

### 数据库集成与前后端对接
- 数据库（MySQL/PostgreSQL）
  - 读：`Execute Query` 示例：`SELECT id, name, updated_at FROM users WHERE updated_at > NOW() - INTERVAL '1 day';`
  - 写：`INSERT INTO logs(user_id, action, ts) VALUES({{$json.id}}, {{$json.action}}, NOW());`
  - Upsert 示例（Postgres）：`INSERT ... ON CONFLICT (id) DO UPDATE SET name=EXCLUDED.name;`
  - 建议：在上游用 Set/Function 统一字段类型与命名，避免 SQL 拼接错误。
  - 节点配置字段清单（MySQL）：`Host`、`Port`、`Database`、`User`、`Password`、`SSL`、`Operation`（Query/Insert/Update）、`Query`/`Table`、`Options`（超时/SSL）。
  - 节点配置字段清单（Postgres）：`Host`、`Port`、`Database`、`Schema`、`User`、`Password`、`SSL`、`Operation`、`Query`、`Options`。
  - 参数化示例（表达式注入）：
    - `INSERT INTO logs(user_id, action) VALUES ({{$json.userId}}, '{{$json.action}}')`。
    - 风险提示：避免将未校验的外部输入直接拼接到 SQL；尽量做类型转换与白名单校验。
  - 字段映射清单示例（users 表）：`id`（UUID/INT）、`name`（TEXT）、`email`（TEXT UNIQUE）、`updated_at`（TIMESTAMP）、`status`（SMALLINT）。
     - Set 映射示例：`id={{$json.id}}`、`email={{$json.email?.toLowerCase?.()}}`、`status={{Number($json.status) || 0}}`。
   - 截图占位：
     - MySQL 节点配置（Host/Port/SSL/Operation/Query）：`/styles/images/post-n8n/mysql-node-config.png`（待补图）。
     - Postgres 节点配置：`/styles/images/post-n8n/postgres-node-config.png`（待补图）。
     - Respond to Webhook 响应设置：`/styles/images/post-n8n/respond-webhook.png`（待补图）。
 - 前端对接（Webhook + Respond to Webhook）
  - 表单提交到：`POST /webhook/form-submit`；首节点校验必填字段与签名。
  - 使用 `Respond to Webhook` 返回 JSON 响应给前端：`{"ok": true, "id": "{{$json.id}}"}`。
  - CORS/安全：在反向代理层处理跨域与鉴权（如 Basic Auth/Token）。
  - 节点配置字段清单（Respond to Webhook）：`Status Code`、`Response Data`（JSON/Text）、`Headers`（如 `Content-Type`、自定义 `X-Request-Id`）。
- 示例流程：`Webhook → Validate(Function) → Write(DB) → Notify(IM) → Respond`
 
 ## 数据与表达式

### 作用域与引用
- `$json`：当前节点输入数据（单条 item）。
- `$node["NodeName"].json`：引用指定节点的输出数据。
- `$items()`：获取所有输入 items（数组），常用于聚合/映射。
- `$flow`：工作流级变量（在多个节点间共享）。
- `$env`：环境变量（从部署环境注入）。

### 常用表达式示例
- 字段取值：`{{$json.name}}`、`{{$node["HTTP Request"].json.status}}`
- 计算与默认值：`{{$json.total * 1.2}}`、`{{$json.name || 'guest'}}`
- 批量映射（Set 节点字段值）：`{{$items().map(i => i.json.id)}}`
- 时间与随机：`{{$now}}`、`{{Math.random()}}`

### Set 与 Function 对比
- Set（表达式方式）适合“声明式”字段映射：
```json
{
  "user": "{{$json.name}}",
  "ok": "{{$node[\"HTTP Request\"].json.success}}",
  "ts": "{{$now}}"
}
```
- Function（JS 方式）适合复杂转换：
```javascript
// 将列表拆分并规范化
return items.flatMap(item => {
  const list = Array.isArray(item.json.list) ? item.json.list : [];
  return list.map(x => ({ json: { id: String(x.id), value: Number(x.value || 0) } }));
});
```

### 错误处理与防御式表达式
- `Continue On Fail`：允许出错后继续下游，便于旁路记录与告警。
- 条件兜底：`{{$node["Foo"].json && $node["Foo"].json.bar || 0}}`
- 失败分支：用 `IF` 判断 `{{$node["HTTP Request"].statusCode >= 400}}` 进入告警路径。


## 凭据与安全

### 凭据类型与用法
- 类型：API Key、Basic Auth、OAuth2 等，集中在“凭据”中管理。
- 用法：在节点内选择已保存的凭据，即可复用连接配置与鉴权策略。
- 建议：将敏感值通过环境变量注入，避免硬编码在工作流字段中。

### 环境变量与敏感信息
- 在 Docker Compose 中定义敏感信息：
```yaml
services:
  n8n:
    image: n8nio/n8n:latest
    environment:
      - N8N_HOST=localhost
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      - N8N_ENCRYPTION_KEY=replace-with-strong-secret
      - N8N_LOG_LEVEL=info
      - TZ=Asia/Shanghai
    volumes:
      - ./n8n_data:/home/node/.n8n
```
- 在节点字段中可用表达式引用环境变量：`{{$env.MY_TOKEN}}`。
- 加密与密钥：`N8N_ENCRYPTION_KEY` 用于对凭据数据加密，务必设置且妥善保管。

### Webhook 入站安全
- 做法：自定义请求头携带 `X-Secret`，在工作流首个节点校验。
- 示例（Function 节点校验）：
```javascript
const secret = $json.headers?.['x-secret'] || $json.headers?.['X-Secret'];
if (secret !== $env.SECRET_TOKEN) {
  throw new Error('Unauthorized: invalid secret');
}
return items; // 通过校验后继续
```
- 结合 IF 节点：未通过校验进入告警分支（记录与通知）。

### OAuth2 配置提示
- 回调地址需与部署域名一致（确保与反向代理/HTTPS 配置匹配）。
- 设置最小权限范围（Scopes），避免过度授权。
- 对令牌做轮换与过期处理，异常分支写入告警渠道。

### 审计与访问控制
- UI 访问控制：限制管理端口暴露范围（仅内网/堡垒机），必要时加反向代理认证。
- 执行审计：失败与成功执行都保留记录，关键路径启用告警通知。
- 网络隔离：将 n8n 放在受控子网中，对外访问通过网关统一出口。

### 备份与恢复
- 备份目录：`./n8n_data`（含工作流与凭据等）与外部数据库（如 Postgres）。
- 恢复注意：加密密钥需一致，否则凭据无法解密。
- 建议建立定时备份与异地存储策略。

## 部署与运维

### 生产化 Compose（PostgreSQL）
```yaml
version: "3.8"
services:
  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    ports:
      - "5678:5678"
    environment:
      - N8N_HOST=localhost
      - N8N_PORT=5678
      - N8N_PROTOCOL=http
      - WEBHOOK_URL=http://localhost:5678/
      - N8N_ENCRYPTION_KEY=replace-with-strong-secret
      - N8N_LOG_LEVEL=info
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=db
      - DB_POSTGRESDB_DATABASE=n8n
      - DB_POSTGRESDB_USER=n8n
      - DB_POSTGRESDB_PASSWORD=strong-password
      - DB_POSTGRESDB_PORT=5432
      - TZ=Asia/Shanghai
    volumes:
      - ./n8n_data:/home/node/.n8n
    depends_on:
      - db
    restart: unless-stopped
  db:
    image: postgres:14
    container_name: n8n-db
    environment:
      - POSTGRES_USER=n8n
      - POSTGRES_PASSWORD=strong-password
      - POSTGRES_DB=n8n
    volumes:
      - ./pg_data:/var/lib/postgresql/data
    restart: unless-stopped
```
- 适用：需要更强的并发与数据可靠性时，使用外部数据库。
- 注意：升级前先备份 `n8n_data` 与 `pg_data`，保持 `N8N_ENCRYPTION_KEY` 不变。

### 企业内网部署
- 端口与域名：使用内网域名与反向代理（Nginx/Caddy），将外部入站限制在网关层。
- Webhook URL：将 `WEBHOOK_URL` 指向内网域名，例如：`http://n8n.internal/`。
- 示例（Nginx 片段）：
```nginx
server {
  listen 80;
  server_name n8n.internal;
  location / {
    proxy_pass http://127.0.0.1:5678;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}
```
- 访问控制：在代理层加 Basic Auth/白名单，结合网段隔离提升安全性。

### 日志与监控
- 日志级别：通过 `N8N_LOG_LEVEL=info|debug` 控制；问题定位时短暂打开 `debug`。
- 执行监控：在 UI 中查看工作流执行记录，关键路径增加失败重试与告警节点。
- 指标采集：可用 Webhook 推送执行摘要到监控系统（如 Prometheus 网关/ELK）。

### 升级与备份
- 升级：`docker compose pull && docker compose up -d`。
- 备份：定期备份 `n8n_data`（以及外部 DB），在变更前做一次快照。
- 回滚：保留上一个版本镜像与数据快照，问题时快速恢复。

### 横向扩展（参考）
- 高并发场景可考虑队列模式（结合消息队列/缓存），将执行与触发分离。
- 对外高频 API 调用需在工作流内做限速与熔断（IF+Wait+重试）。

## 最佳实践

### 工作流命名与结构
- 命名建议：`领域-场景-动作`（如 `crm-sync-contacts`）。
- 结构建议：按业务域分组，核心流程与支撑流程分层管理。
- 字段约定：维持稳定的 JSON 契约，避免下游因字段漂移而失败。

### 子工作流与模板化
- 复用方式：使用 `Execute Workflow` 将常见步骤做成子工作流（如鉴权、分页拉取）。
- 模板库：为团队沉淀常用集成模板（如邮件告警、CSV 解析、API 拉取）。
- 版本管理：模板变更需记录说明与兼容性提示。

### 错误处理与重试策略
- 失败分支：`IF` 检查状态码或字段异常，进入告警与旁路记录。
- 重试与退避：配合 `Wait` 节点做指数退避，示例：1m→2m→5m。
- 死信与隔离：对持续失败的 items 写入队列/表，人工介入处理。

### 速率限制与并发控制
- 限速：对外部 API 做速率限制（串行/Wait 节点）；批量任务拆小批次。
- 并发：避免在同一工作流内对同一资源并发写入，必要时加锁/排队。

### 数据映射与校验
- 使用 Set 节点统一字段命名与类型转换；
- 在关键节点前做必填字段校验，异常进入兜底分支。

### 输入校验与输出脱敏
- 校验策略：必填、类型、枚举/范围、正则；在 Webhook/Function 首节点执行。
- Function 校验示例：
```javascript
const required = ['id', 'email'];
for (const f of required) {
  if (!$json[f]) {
    throw new Error(`missing ${f}`);
  }
}
const email = String($json.email || '').toLowerCase();
if (!/^[^@]+@[^@]+$/.test(email)) {
  throw new Error('invalid email');
}
return [{ json: { ...$json, email } }];
```
- 输出脱敏：日志/告警/外显字段做脱敏；示例：`{{$json.phone?.replace(/\d{4}$/, '****')}}`；敏感字段移除（Set 删除 `password`、`token`）。
- 契约约束：为入/出参定义 JSON Schema（可在 Function 校验），稳定字段集合与类型，避免下游破坏。
